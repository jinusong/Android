# Activity And Intent - Summary
---
## 요약
* **액티비티와 인텐트의 형태로 독립적으로 실행 가능한 모듈을 생성함으로써 재사용성과 상호 운용성이 극대화된다. 또한, 콘텐트 재공자를 구현하면 애플리케이션 간의 데이터 공유가 가능하다.**
* **액티비티에서는 사용자가 애플리케이션과 상호작용하는 데 초점을 두는 반면, 백그라운드 프로세싱은 서비스와 브로드캐스트 수신자에 의해 처리된다.**
* **애플리케이션을 구성하는 컴포넌트들은 매니페스트 파일에 정의되어 안드로이드 런타임 시스템에 의해 참조된다. 그리고 애플리케이션 매니페스트 파일과 애플리케이션 리소스들이 결합되어 애플리케이션의 컨텍스트를 나타낸다.**
---
## 1. Activity
### 안드로이드는 재사용 가능한 컴포넌트의 개념을 더 높은 수준으로 끌어올렸다. 그것이 바로 Activity이다.
* 안드로이드 어플리케이션은 액티비티라는 컴포넌트가 하나 이상 결합되어 생성되고 애플리케이션의 기능을 갖는 단일의 독립 실행셩 모듈이다.
* 액티비티는 하나의 사용자 인터페이스 화면 및 그것의 기능과 밀접하게 연관되어있다.
* 액티비티는 안드로이드 Activity 클래스의 서브 클래스로 생성되어야 하며, 애들리케이션의 다른 액티비티와 완전히 독립적으로 구현되어야 한다. 
* 다시말해 액티비티는 다른 액티비티의 메서드를 직접 호출할 수 없으며, 데이터도 직접 액세스할 수 없다. 
하지만 **Intent와 Content Provider를 사용하여 액티비티를 공유할 수 있다.**
---
## 2. Android Intent
### Intent는 하나의 액티비티가 다른 액티비티를 론칭시킬 수 있는 매커니즘이다.
* 액티비티가 안드로이드 런타임에 인텐트를 요청하면 그 인텐트에 부합되는 액티비티를 안드로이드 런타임이 찾아서 시작시킨다. 한 액티비티가 다른 액티비티를 직접 시작시키는 것이 아니다.
* 인텐트에서는 수행될 오퍼레이션을 나타내고, 필요하다면 전달할 데이터도 포함시킬 수 있다.
* 인텐트에는 **Explicit(명시적)**, **Implicit(암시적) 인텐트**가 있다.
* **명시적 인텐트**에서는 클래스 이름으로 액티비티를 참조하여 액티비티 론칭을 안드로이드 런타임에 요청하기 때문에 론칭할 액티비티를 정확하게 잘 알아야 한다.
* **암시적 인텐트**는 원하는 액션 타입을 안드로이드 런타임에 알려준다. 그런 작업을 할 수 있다고 자신이 등록한 액티비티를 안드로이드 런타임이 찾아서 시작시킨다. 만약 그런 능력의 액티비티가 하나 이상일 경우 사용자가 선택할 수 있도로액티비티를 안드로이드 런타임이 찾아서 시작시킨다. 만약 그런 능력의 액티비티가 하나 이상일 경우 사용자가 선택할 수 있도록 한다.
---
## 3. Broadcast Intent
### Broadcast Receiver로 등록된 모든 애플리케이션에 전송되는 시스템 차원의 인텐트다.
* 안드로이드 시스템에서는 **장치 상태의 변화를 알려주기 위해 브로드캐스트 인텐트를 전송**한다.
* 브로드캐스트 인텐트는 일반적인 인텐트와 유사하게 동작하지만, 지정된 컴포넌트만 인텐트를 받는 것이 아니라 시스템의 여러 컴포넌트가 동시에 받을 수 있다는 차이점이 있다.
* 브로드캐스트 인텐트에는 **Normal(정규)**와 **Ordered(순차)**의 두 종류가 있다.
* **정규 브로드캐스트 인텐트**는 관련 이벤트에 관심있는 모든 브로드캐스트 수신자에게 비동기 형태로 동시에 전송된다.
* **순차 브로드캐스트 인텐트**는 한 번에 하나의 브로드캐스트 수신자에게 전송된다. 그리고 그 다음 차례의 브로드캐스트 수신자에게 계속 전송되거나 중단될 수 있다.
---
## 4. Broadcast Receiver
### 애플리케이션이 브로드캐스트 인텐트에 응답할 수 있는 매커니즘이다.
* 브로트캐스트 수신자는 애플리케이션에서 등록해야 하며, 관심 있는 브로드캐스트 타입을 나타내는 **Intent Filter를 사용하여 구성**한다.
* 등록된 브로드캐스트 타입이 인텐트와 일치하면 안드로이드 런타임이 그 수신자를 시작시킨다.
* 수신자는 필요한 작업을 5초 이내에 수행하고 복귀해야한다.(메시지 알림 등)
* **브로드캐스트 수신자는 백그라운드로 실행되며 사용자 인터페이스를 갖지 않는다.**
---
## 5. Android Service
### Android Service는 백그라운드로 실행되는 프로세스이며, 사용자 인터페이스를 갖지 않는다.
* 서비스가 시작된 후에는 액티비티나 브로드캐스트 수신자 및 그 외 다른 서비스로부터 관리된다.
* 사용자에게 보여줄 수 있는 사용자 인터페이스는 필요 없는 경우에 안드로이드 서비스가 이상적이다.
* **사용자 인터페이스는 없지만 Toast나 Notification를 사용하여 사용자에게 메시지를 전달할 수 있다. 인텐트도 요청할 수 있다.**
* 서비스는 안드로이드 런타임에 의해 다른 프로세스들보다 높은 우선순위에 위치한다. 메모리가 부족하여 리소스를 해제하더라도 가장 최후에 리소스가 해제된다. 리소스가 사용 가능해지면 다시 실행한다.
* 포그라운드에서 실행된 필요가 있다고 선언함으로써 중단의 위험을 줄일 수 있다. 그럴 떄는 **startForeground()를 호출**하면 된다. 그러나 서비스가 중단되면 사용자레게 해를 끼칠 수 있을 때만 그렇게 하는 것이 좋다.
* 서비스의 실제적인 솔루션으로는 오디오의 스트리밍, 주식 어플리케이션이 있다.
---
## 6. Content Provider
### 애플리케이션 간에 데이터를 공유하는 메커니즘을 구현하는 것이 Content Provider이다.
* 자신의 내부 테이터에 대한 액세스를 다른 애플리케이션에게 제공할 수 있다. 그 데이터를 추가, 삭제, 조회하는 능력을 갖는 콘텐트 제공자를 구현한다.
* 데이터의 액세스는 콘텐트 제공자가 정의한 URI를 통해 제공된다. 데이터는 파일 또는 SQLite 데이터베이스 전테의 형태로 공유한다.
* 연락처와 같은 네이티브 안드로이드 애플리케이션들은 다른 애플리케이션에서 데이터를 액세스할 수 있는 표준 콘텐트를 많이 포함하고 있다.
* 안드로이드 시스템에서 **현재 사용 가능한 콘텐트 제공자는 콘텐트 리졸버(Content Resolver)를 사용해서 찾을 수 있다.**
---
## 7. Manifest
### 앱을 구성하는 다양한 요소를 합치는 접착제의 역할을 하는 것이 안드로이드 Manifest 파일이다.
* XML파일이며, 액티비티, 서비스, 브로드캐스트 수신자, 데이터 제공자, 퍼미션(permission) 등이 정의 되어 있다. 이 것들을 안드로이드 런타임에서 참조하고 사용한다.
---
## 8. Application Resources
### APK로 빌드되어 장치에 설치 및 실행된다. 자바 실행 코드, 매니페스트 파일의 메타 데이터, 각종 리소스 파일들이 포함된다.
* XML로 정의된 사용자 인터페이스 레이아웃과 함꼐 사용자 인터페이스에 나타나는 문자열, 이미지, 폰트와 색상 등이다.
---
## 9. Application Context
### 애플리케이션의 매니페스트 파일과 그런 리소스들이 결합되어 Application Context라는 것이 생성된다.
* 애플리케이션이 컴파일되면 애플리케이션의 모든 리소스에 대한 참조를 포함하는 R이라는 이름의 클래스가 자동 생성된다.
* 컨택스트는 **안드로이드 Context 클래스**로 나타내며, 런타임 시에 애플리케이션의 리소스를 액세스하기 위해 애플리케이션 코드에서 사용될 수 있다.
* **런타임 시의 정보를 수집하고 애플리케이션의 환경을 변경하기 위해 애플리케이션의 컨텍스트에서 여러 가지 메서드들이 호출될 수 있다.**